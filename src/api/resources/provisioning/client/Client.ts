// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as Forum from "../../../index.js";

export declare namespace ProvisioningClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

/**
 * Platform-level instance management using your provisioning key
 */
export class ProvisioningClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<ProvisioningClient.Options>;

    constructor(options: ProvisioningClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * Retrieve all instances owned by the authenticated user. Use the `handle` query parameter to get a single instance with its API key.
     *
     * @param {Forum.ListProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.list()
     */
    public list(
        request: Forum.ListProvisioningRequest = {},
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.ListProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__list(request, requestOptions));
    }

    private async __list(
        request: Forum.ListProvisioningRequest = {},
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.ListProvisioningResponse>> {
        const { handle } = request;
        const _queryParams: Record<string, unknown> = {
            handle,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.ListProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/instances");
    }

    /**
     * Create a new forum instance. Returns the instance details including the API key for accessing the forum API.
     *
     * @param {Forum.CreateInstance} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.create({
     *         name: "name",
     *         handle: "handle"
     *     })
     */
    public create(
        request: Forum.CreateInstance,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.CreateProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__create(request, requestOptions));
    }

    private async __create(
        request: Forum.CreateInstance,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.CreateProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.CreateProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/instances");
    }

    /**
     * Update an instance's name or handle. The `handle` field identifies which instance to update.
     *
     * @param {Forum.UpdateInstance} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.update({
     *         handle: "handle"
     *     })
     */
    public update(
        request: Forum.UpdateInstance,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.UpdateProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__update(request, requestOptions));
    }

    private async __update(
        request: Forum.UpdateInstance,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.UpdateProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances",
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.UpdateProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/instances");
    }

    /**
     * Permanently delete an instance. This action cannot be undone.
     *
     * @param {Forum.DeleteInstance} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.delete({
     *         handle: "handle"
     *     })
     */
    public delete(
        request: Forum.DeleteInstance,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.DeleteProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__delete(request, requestOptions));
    }

    private async __delete(
        request: Forum.DeleteInstance,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.DeleteProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances",
            ),
            method: "DELETE",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.DeleteProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/instances");
    }

    /**
     * Retrieve billing and subscription information for an instance.
     *
     * @param {Forum.GetBillingProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.getBilling({
     *         handle: "handle"
     *     })
     */
    public getBilling(
        request: Forum.GetBillingProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.GetBillingProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getBilling(request, requestOptions));
    }

    private async __getBilling(
        request: Forum.GetBillingProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.GetBillingProvisioningResponse>> {
        const { handle } = request;
        const _queryParams: Record<string, unknown> = {
            handle,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/billing",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.GetBillingProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/instances/billing");
    }

    /**
     * Change an instance's subscription plan. Returns a checkout URL for upgrades or a billing portal URL for downgrades.
     *
     * @param {Forum.UpgradeInstance} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.changePlan({
     *         handle: "handle",
     *         plan: "FREE"
     *     })
     */
    public changePlan(
        request: Forum.UpgradeInstance,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.ChangePlanProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__changePlan(request, requestOptions));
    }

    private async __changePlan(
        request: Forum.UpgradeInstance,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.ChangePlanProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/billing",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.ChangePlanProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/instances/billing");
    }

    /**
     * Generate a new API key for the instance. The old key will be invalidated.
     *
     * @param {Forum.RegenerateApiKeyProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.regenerateApiKey({
     *         handle: "handle"
     *     })
     */
    public regenerateApiKey(
        request: Forum.RegenerateApiKeyProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.RegenerateApiKeyProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__regenerateApiKey(request, requestOptions));
    }

    private async __regenerateApiKey(
        request: Forum.RegenerateApiKeyProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.RegenerateApiKeyProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/api-key",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Forum.RegenerateApiKeyProvisioningResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/instances/api-key");
    }

    /**
     * Retrieve usage statistics for an instance including API requests, storage, and content counts.
     *
     * @param {Forum.GetUsageProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.getUsage({
     *         handle: "handle"
     *     })
     */
    public getUsage(
        request: Forum.GetUsageProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.GetUsageProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getUsage(request, requestOptions));
    }

    private async __getUsage(
        request: Forum.GetUsageProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.GetUsageProvisioningResponse>> {
        const { handle } = request;
        const _queryParams: Record<string, unknown> = {
            handle,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/usage",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.GetUsageProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/instances/usage");
    }

    /**
     * Retrieve all team members for an instance.
     *
     * @param {Forum.ListTeamProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.listTeam({
     *         handle: "handle"
     *     })
     */
    public listTeam(
        request: Forum.ListTeamProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.ListTeamProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listTeam(request, requestOptions));
    }

    private async __listTeam(
        request: Forum.ListTeamProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.ListTeamProvisioningResponse>> {
        const { handle } = request;
        const _queryParams: Record<string, unknown> = {
            handle,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/team",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.ListTeamProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/instances/team");
    }

    /**
     * Invite new team members to an instance.
     *
     * @param {Forum.InviteTeamProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.inviteTeam({
     *         handle: "handle",
     *         members: [{
     *                 email: "email"
     *             }]
     *     })
     */
    public inviteTeam(
        request: Forum.InviteTeamProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.InviteTeamProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__inviteTeam(request, requestOptions));
    }

    private async __inviteTeam(
        request: Forum.InviteTeamProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.InviteTeamProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/team",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.InviteTeamProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/instances/team");
    }

    /**
     * Remove a team member from an instance.
     *
     * @param {Forum.RemoveTeamMemberProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.removeTeamMember({
     *         handle: "handle",
     *         email: "email"
     *     })
     */
    public removeTeamMember(
        request: Forum.RemoveTeamMemberProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.RemoveTeamMemberProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__removeTeamMember(request, requestOptions));
    }

    private async __removeTeamMember(
        request: Forum.RemoveTeamMemberProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.RemoveTeamMemberProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/team",
            ),
            method: "DELETE",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Forum.RemoveTeamMemberProvisioningResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/instances/team");
    }

    /**
     * Retrieve all custom domains for an instance.
     *
     * @param {Forum.ListDomainsProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.listDomains({
     *         handle: "handle"
     *     })
     */
    public listDomains(
        request: Forum.ListDomainsProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.ListDomainsProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listDomains(request, requestOptions));
    }

    private async __listDomains(
        request: Forum.ListDomainsProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.ListDomainsProvisioningResponse>> {
        const { handle } = request;
        const _queryParams: Record<string, unknown> = {
            handle,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/domains",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Forum.ListDomainsProvisioningResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/instances/domains");
    }

    /**
     * Add a custom domain to an instance.
     *
     * @param {Forum.AddDomainProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.addDomain({
     *         handle: "handle",
     *         name: "name"
     *     })
     */
    public addDomain(
        request: Forum.AddDomainProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.AddDomainProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__addDomain(request, requestOptions));
    }

    private async __addDomain(
        request: Forum.AddDomainProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.AddDomainProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/domains",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.AddDomainProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/instances/domains");
    }

    /**
     * Remove a custom domain from an instance.
     *
     * @param {Forum.RemoveDomainProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.removeDomain({
     *         handle: "handle",
     *         name: "name"
     *     })
     */
    public removeDomain(
        request: Forum.RemoveDomainProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.RemoveDomainProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__removeDomain(request, requestOptions));
    }

    private async __removeDomain(
        request: Forum.RemoveDomainProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.RemoveDomainProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/domains",
            ),
            method: "DELETE",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Forum.RemoveDomainProvisioningResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/instances/domains");
    }

    /**
     * Export all data from an instance including threads, posts, users, tags, etc.
     *
     * @param {Forum.ExportDataProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.exportData({
     *         handle: "handle"
     *     })
     */
    public exportData(
        request: Forum.ExportDataProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.ExportDataProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__exportData(request, requestOptions));
    }

    private async __exportData(
        request: Forum.ExportDataProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.ExportDataProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/export",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Forum.ExportDataProvisioningResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/instances/export");
    }

    /**
     * Retrieve all webhooks configured for an instance.
     *
     * @param {Forum.ListWebhooksProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.listWebhooks({
     *         handle: "handle"
     *     })
     */
    public listWebhooks(
        request: Forum.ListWebhooksProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.ListWebhooksProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listWebhooks(request, requestOptions));
    }

    private async __listWebhooks(
        request: Forum.ListWebhooksProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.ListWebhooksProvisioningResponse>> {
        const { handle } = request;
        const _queryParams: Record<string, unknown> = {
            handle,
        };
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/webhooks",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Forum.ListWebhooksProvisioningResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/instances/webhooks");
    }

    /**
     * Create a new webhook for an instance.
     *
     * @param {Forum.CreateWebhookProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.createWebhook({
     *         handle: "handle",
     *         url: "url",
     *         events: ["events"]
     *     })
     */
    public createWebhook(
        request: Forum.CreateWebhookProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.CreateWebhookProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createWebhook(request, requestOptions));
    }

    private async __createWebhook(
        request: Forum.CreateWebhookProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.CreateWebhookProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/webhooks",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Forum.CreateWebhookProvisioningResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/instances/webhooks");
    }

    /**
     * Update an existing webhook.
     *
     * @param {Forum.UpdateWebhookProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.updateWebhook({
     *         handle: "handle",
     *         webhookId: "webhookId"
     *     })
     */
    public updateWebhook(
        request: Forum.UpdateWebhookProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.UpdateWebhookProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateWebhook(request, requestOptions));
    }

    private async __updateWebhook(
        request: Forum.UpdateWebhookProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.UpdateWebhookProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/webhooks",
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Forum.UpdateWebhookProvisioningResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "PUT", "/instances/webhooks");
    }

    /**
     * Delete a webhook from an instance.
     *
     * @param {Forum.DeleteWebhookProvisioningRequest} request
     * @param {ProvisioningClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Forum.BadRequestError}
     * @throws {@link Forum.UnauthorizedError}
     * @throws {@link Forum.NotFoundError}
     * @throws {@link Forum.InternalServerError}
     *
     * @example
     *     await client.provisioning.deleteWebhook({
     *         handle: "handle",
     *         webhookId: "webhookId"
     *     })
     */
    public deleteWebhook(
        request: Forum.DeleteWebhookProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): core.HttpResponsePromise<Forum.DeleteWebhookProvisioningResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteWebhook(request, requestOptions));
    }

    private async __deleteWebhook(
        request: Forum.DeleteWebhookProvisioningRequest,
        requestOptions?: ProvisioningClient.RequestOptions,
    ): Promise<core.WithRawResponse<Forum.DeleteWebhookProvisioningResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                "x-provisioning-key": requestOptions?.provisioningKey ?? this._options?.provisioningKey,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ForumEnvironment.Production,
                "instances/webhooks",
            ),
            method: "DELETE",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Forum.DeleteWebhookProvisioningResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Forum.BadRequestError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 401:
                    throw new Forum.UnauthorizedError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Forum.NotFoundError(_response.error.body as Forum.ErrorResponse, _response.rawResponse);
                case 500:
                    throw new Forum.InternalServerError(
                        _response.error.body as Forum.ErrorResponse,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ForumError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "DELETE", "/instances/webhooks");
    }
}
